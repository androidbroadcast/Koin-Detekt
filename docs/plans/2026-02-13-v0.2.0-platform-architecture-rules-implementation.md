# v0.2.0 Platform & Architecture Rules Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add 10 new Detekt rules for Koin: 7 platform-specific (Compose/Ktor/Android) + 3 architecture boundary rules

**Architecture:** Expand existing rule structure with new platform/ and architecture/ packages. Follow established TDD patterns from existing rules. Maintain 98%/70% coverage.

**Tech Stack:** Kotlin 2.0, Detekt 1.23.8+, JUnit 5, AssertJ, Kover

**Design Document:** [docs/plans/2026-02-13-detekt-koin-v0.2-v0.4-expansion-design.md](./2026-02-13-detekt-koin-v0.2-v0.4-expansion-design.md)

---

## Phase 1: Platform Rules - Compose (Days 1-2)

### Task 1: KoinViewModelOutsideComposable - Basic Test

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinViewModelOutsideComposableTest.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.compose

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class KoinViewModelOutsideComposableTest {

    @Test
    fun `reports koinViewModel outside Composable function`() {
        val code = """
            fun MyScreen() {
                val viewModel = koinViewModel<MyViewModel>()
            }
        """.trimIndent()

        val findings = KoinViewModelOutsideComposable(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("koinViewModel")
        assertThat(findings[0].message).contains("@Composable")
    }

    @Test
    fun `allows koinViewModel in Composable function`() {
        val code = """
            @Composable
            fun MyScreen() {
                val viewModel = koinViewModel<MyViewModel>()
            }
        """.trimIndent()

        val findings = KoinViewModelOutsideComposable(Config.empty).lint(code)

        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "KoinViewModelOutsideComposableTest" --no-daemon`
Expected: FAIL with "KoinViewModelOutsideComposable class not found"

**Step 3: Create rule implementation file**

Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinViewModelOutsideComposable.kt`

```kotlin
package io.github.krozov.detekt.koin.platform.compose

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType

/**
 * Detects `koinViewModel()` calls outside `@Composable` functions.
 *
 * `koinViewModel()` requires Composition context and will crash at runtime
 * if called outside a Composable function.
 *
 * <noncompliant>
 * fun MyScreen() {
 *     val vm = koinViewModel<MyVM>() // Runtime crash!
 * }
 * </noncompliant>
 *
 * <compliant>
 * @Composable
 * fun MyScreen() {
 *     val vm = koinViewModel<MyVM>()
 * }
 * </compliant>
 */
public class KoinViewModelOutsideComposable(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "KoinViewModelOutsideComposable",
        severity = Severity.Warning,
        description = "koinViewModel() must be called inside @Composable function",
        debt = Debt.FIVE_MINS
    )

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName != "koinViewModel") return

        val containingFunction = expression.getStrictParentOfType<KtNamedFunction>() ?: return
        val annotations = containingFunction.annotationEntries.mapNotNull { it.shortName?.asString() }

        if ("Composable" !in annotations) {
            report(
                CodeSmell(
                    issue,
                    Entity.from(expression),
                    "koinViewModel() called outside @Composable function. " +
                            "This will cause a runtime crash. Add @Composable annotation to the function."
                )
            )
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "KoinViewModelOutsideComposableTest" --no-daemon`
Expected: PASS (2 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinViewModelOutsideComposable.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinViewModelOutsideComposableTest.kt
git commit -m "feat(compose): add KoinViewModelOutsideComposable rule

Detects koinViewModel() calls outside @Composable functions.
Prevents runtime crashes when Composition context is missing.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 2: KoinViewModelOutsideComposable - Edge Cases

**Files:**
- Modify: `src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinViewModelOutsideComposableTest.kt`

**Step 1: Add edge case tests**

Add to test file:

```kotlin
@Test
fun `allows koinViewModel in inline Composable`() {
    val code = """
        @Composable
        inline fun MyScreen() {
            val viewModel = koinViewModel<MyViewModel>()
        }
    """.trimIndent()

    val findings = KoinViewModelOutsideComposable(Config.empty).lint(code)
    assertThat(findings).isEmpty()
}

@Test
fun `reports koinViewModel in init block`() {
    val code = """
        class MyClass {
            init {
                val viewModel = koinViewModel<MyViewModel>()
            }
        }
    """.trimIndent()

    val findings = KoinViewModelOutsideComposable(Config.empty).lint(code)
    assertThat(findings).hasSize(1)
}

@Test
fun `ignores other viewModel calls`() {
    val code = """
        fun MyScreen() {
            val viewModel = viewModel<MyViewModel>()
        }
    """.trimIndent()

    val findings = KoinViewModelOutsideComposable(Config.empty).lint(code)
    assertThat(findings).isEmpty()
}

@Test
fun `handles qualified koinViewModel call`() {
    val code = """
        @Composable
        fun MyScreen() {
            val viewModel = koinViewModel<MyViewModel>(qualifier = named("test"))
        }
    """.trimIndent()

    val findings = KoinViewModelOutsideComposable(Config.empty).lint(code)
    assertThat(findings).isEmpty()
}
```

**Step 2: Run tests**

Run: `./gradlew test --tests "KoinViewModelOutsideComposableTest" --no-daemon`
Expected: PASS (6 tests total)

**Step 3: Commit**

```bash
git add src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinViewModelOutsideComposableTest.kt
git commit -m "test(compose): add edge cases for KoinViewModelOutsideComposable

Add tests for:
- Inline Composable functions
- Init blocks
- Other viewModel() variants
- Qualified calls

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 3: KoinInjectInPreview - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinInjectInPreviewTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinInjectInPreview.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.compose

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class KoinInjectInPreviewTest {

    @Test
    fun `reports koinInject in Preview function`() {
        val code = """
            @Preview
            @Composable
            fun MyScreenPreview() {
                val repository = koinInject<Repository>()
                MyScreen(repository)
            }
        """.trimIndent()

        val findings = KoinInjectInPreview(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("koinInject")
        assertThat(findings[0].message).contains("@Preview")
    }

    @Test
    fun `allows koinInject in non-Preview Composable`() {
        val code = """
            @Composable
            fun MyScreen() {
                val repository = koinInject<Repository>()
            }
        """.trimIndent()

        val findings = KoinInjectInPreview(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows regular parameters in Preview`() {
        val code = """
            @Preview
            @Composable
            fun MyScreenPreview() {
                MyScreen(FakeRepository())
            }
        """.trimIndent()

        val findings = KoinInjectInPreview(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "KoinInjectInPreviewTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.platform.compose

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType

/**
 * Detects `koinInject()` calls in `@Preview` functions.
 *
 * Compose Previews run without Koin context, causing crashes when trying to inject dependencies.
 * Use fake/mock implementations or preview parameters instead.
 *
 * <noncompliant>
 * @Preview
 * @Composable
 * fun MyScreenPreview() {
 *     val repo = koinInject<Repository>() // Preview crash!
 *     MyScreen(repo)
 * }
 * </noncompliant>
 *
 * <compliant>
 * @Preview
 * @Composable
 * fun MyScreenPreview() {
 *     MyScreen(FakeRepository())
 * }
 * </compliant>
 */
public class KoinInjectInPreview(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "KoinInjectInPreview",
        severity = Severity.Warning,
        description = "koinInject() should not be used in @Preview functions",
        debt = Debt.FIVE_MINS
    )

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName != "koinInject") return

        val containingFunction = expression.getStrictParentOfType<KtNamedFunction>() ?: return
        val annotations = containingFunction.annotationEntries.mapNotNull { it.shortName?.asString() }

        if ("Preview" in annotations) {
            report(
                CodeSmell(
                    issue,
                    Entity.from(expression),
                    "koinInject() called in @Preview function. " +
                            "Previews run without Koin context and will crash. " +
                            "Use fake/mock implementations or @Preview parameters instead."
                )
            )
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "KoinInjectInPreviewTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinInjectInPreview.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/KoinInjectInPreviewTest.kt
git commit -m "feat(compose): add KoinInjectInPreview rule

Detects koinInject() in @Preview functions.
Prevents preview crashes due to missing Koin context.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 4: RememberKoinModulesLeak - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/RememberKoinModulesLeakTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/compose/RememberKoinModulesLeak.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.compose

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class RememberKoinModulesLeakTest {

    @Test
    fun `reports loadKoinModules in remember without unload`() {
        val code = """
            @Composable
            fun FeatureScreen() {
                remember { loadKoinModules(featureModule) }
            }
        """.trimIndent()

        val findings = RememberKoinModulesLeak(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("loadKoinModules")
        assertThat(findings[0].message).contains("remember")
    }

    @Test
    fun `allows loadKoinModules with DisposableEffect`() {
        val code = """
            @Composable
            fun FeatureScreen() {
                DisposableEffect(Unit) {
                    loadKoinModules(featureModule)
                    onDispose { unloadKoinModules(featureModule) }
                }
            }
        """.trimIndent()

        val findings = RememberKoinModulesLeak(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows remember without loadKoinModules`() {
        val code = """
            @Composable
            fun MyScreen() {
                val state = remember { mutableStateOf(0) }
            }
        """.trimIndent()

        val findings = RememberKoinModulesLeak(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "RememberKoinModulesLeakTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.platform.compose

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtLambdaExpression
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType

/**
 * Detects `loadKoinModules()` inside `remember {}` without corresponding unload.
 *
 * Memory leak - modules are loaded on every recomposition without cleanup.
 * Use DisposableEffect with unloadKoinModules instead.
 *
 * <noncompliant>
 * @Composable
 * fun FeatureScreen() {
 *     remember { loadKoinModules(featureModule) } // Memory leak!
 * }
 * </noncompliant>
 *
 * <compliant>
 * @Composable
 * fun FeatureScreen() {
 *     DisposableEffect(Unit) {
 *         loadKoinModules(featureModule)
 *         onDispose { unloadKoinModules(featureModule) }
 *     }
 * }
 * </compliant>
 */
public class RememberKoinModulesLeak(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "RememberKoinModulesLeak",
        severity = Severity.Warning,
        description = "loadKoinModules in remember without unload causes memory leak",
        debt = Debt.TEN_MINS
    )

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName != "loadKoinModules") return

        // Check if inside remember {} lambda
        val parentLambda = expression.getStrictParentOfType<KtLambdaExpression>() ?: return
        val rememberCall = parentLambda.parent?.parent as? KtCallExpression ?: return
        val rememberName = rememberCall.calleeExpression?.text ?: return

        if (rememberName == "remember") {
            report(
                CodeSmell(
                    issue,
                    Entity.from(expression),
                    "loadKoinModules() inside remember {} without unloadKoinModules() causes memory leak. " +
                            "Use DisposableEffect with onDispose { unloadKoinModules() } instead."
                )
            )
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "RememberKoinModulesLeakTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/compose/RememberKoinModulesLeak.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/compose/RememberKoinModulesLeakTest.kt
git commit -m "feat(compose): add RememberKoinModulesLeak rule

Detects loadKoinModules in remember without unload.
Prevents memory leaks from unreleased modules.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 2: Platform Rules - Ktor (Day 3)

### Task 5: KtorApplicationKoinInit - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorApplicationKoinInitTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorApplicationKoinInit.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.ktor

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class KtorApplicationKoinInitTest {

    @Test
    fun `reports install Koin in routing block`() {
        val code = """
            fun Application.module() {
                routing {
                    install(Koin) { }
                    get("/api") { }
                }
            }
        """.trimIndent()

        val findings = KtorApplicationKoinInit(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("install(Koin)")
        assertThat(findings[0].message).contains("routing")
    }

    @Test
    fun `allows install Koin in Application module`() {
        val code = """
            fun Application.module() {
                install(Koin) { }
                routing {
                    get("/api") { }
                }
            }
        """.trimIndent()

        val findings = KtorApplicationKoinInit(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `reports install Koin in route handler`() {
        val code = """
            fun Application.module() {
                routing {
                    get("/api") {
                        install(Koin) { }
                    }
                }
            }
        """.trimIndent()

        val findings = KtorApplicationKoinInit(Config.empty).lint(code)
        assertThat(findings).hasSize(1)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "KtorApplicationKoinInitTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.platform.ktor

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtLambdaExpression
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType

/**
 * Detects `install(Koin)` in routing blocks or route handlers.
 *
 * Koin should be initialized once at application level, not per-route.
 * Multiple Koin installations cause configuration conflicts.
 *
 * <noncompliant>
 * fun Application.module() {
 *     routing {
 *         install(Koin) { } // Wrong!
 *         get("/api") { }
 *     }
 * }
 * </noncompliant>
 *
 * <compliant>
 * fun Application.module() {
 *     install(Koin) { }
 *     routing {
 *         get("/api") { }
 *     }
 * }
 * </compliant>
 */
public class KtorApplicationKoinInit(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "KtorApplicationKoinInit",
        severity = Severity.Warning,
        description = "install(Koin) should be at Application level, not in routing",
        debt = Debt.FIVE_MINS
    )

    private var currentDepth = 0
    private var inRouting = false

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return

        // Track routing depth
        if (callName == "routing") {
            inRouting = true
            currentDepth = getCallDepth(expression)
        }

        // Check install(Koin) calls
        if (callName == "install") {
            val typeArg = expression.valueArguments.firstOrNull()?.text
            if (typeArg == "Koin" && inRouting) {
                val depth = getCallDepth(expression)
                if (depth > currentDepth) {
                    report(
                        CodeSmell(
                            issue,
                            Entity.from(expression),
                            "install(Koin) called inside routing block. " +
                                    "Koin should be initialized at Application level. " +
                                    "Move install(Koin) outside routing {} block."
                        )
                    )
                }
            }
        }
    }

    private fun getCallDepth(expression: KtCallExpression): Int {
        var depth = 0
        var current = expression.parent
        while (current != null) {
            if (current is KtLambdaExpression) depth++
            current = current.parent
        }
        return depth
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "KtorApplicationKoinInitTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorApplicationKoinInit.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorApplicationKoinInitTest.kt
git commit -m "feat(ktor): add KtorApplicationKoinInit rule

Detects install(Koin) in routing blocks.
Ensures Koin initialized at Application level only.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 6: KtorRouteScopeMisuse - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorRouteScopeMisuseTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorRouteScopeMisuse.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.ktor

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class KtorRouteScopeMisuseTest {

    @Test
    fun `reports shared koinScope outside route handler`() {
        val code = """
            fun Application.module() {
                val sharedScope = koinScope()
                routing {
                    get("/api") {
                        val service = sharedScope.get<Service>()
                    }
                }
            }
        """.trimIndent()

        val findings = KtorRouteScopeMisuse(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("koinScope")
        assertThat(findings[0].message).contains("shared")
    }

    @Test
    fun `allows call koinScope in route handler`() {
        val code = """
            fun Application.module() {
                routing {
                    get("/api") {
                        call.koinScope().get<Service>()
                    }
                }
            }
        """.trimIndent()

        val findings = KtorRouteScopeMisuse(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "KtorRouteScopeMisuseTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.platform.ktor

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
import org.jetbrains.kotlin.psi.KtProperty

/**
 * Detects incorrect usage of `koinScope()` in Ktor routes.
 *
 * Scopes created outside route handlers are shared across requests,
 * causing state leaks. Each request must have isolated scope.
 *
 * <noncompliant>
 * val sharedScope = koinScope() // Shared across requests!
 * get("/api") {
 *     val service = sharedScope.get<Service>()
 * }
 * </noncompliant>
 *
 * <compliant>
 * get("/api") {
 *     call.koinScope().get<Service>() // Request-scoped
 * }
 * </compliant>
 */
public class KtorRouteScopeMisuse(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "KtorRouteScopeMisuse",
        severity = Severity.Warning,
        description = "koinScope() should be request-scoped, not shared",
        debt = Debt.TEN_MINS
    )

    override fun visitProperty(property: KtProperty) {
        super.visitProperty(property)

        val initializer = property.initializer as? KtCallExpression ?: return
        val callName = initializer.calleeExpression?.text ?: return

        if (callName == "koinScope") {
            // Check if it's call.koinScope() - that's ok
            val receiver = (initializer.parent as? KtDotQualifiedExpression)?.receiverExpression?.text
            if (receiver != "call") {
                report(
                    CodeSmell(
                        issue,
                        Entity.from(property),
                        "koinScope() stored in property creates shared scope across requests. " +
                                "This causes state leaks between requests. " +
                                "Use call.koinScope() inside route handlers for request-scoped dependencies."
                    )
                )
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "KtorRouteScopeMisuseTest" --no-daemon`
Expected: PASS (2 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorRouteScopeMisuse.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/ktor/KtorRouteScopeMisuseTest.kt
git commit -m "feat(ktor): add KtorRouteScopeMisuse rule

Detects shared koinScope across requests.
Prevents state leaks between HTTP requests.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 3: Platform Rules - Android (Day 4)

### Task 7: AndroidContextNotFromKoin - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/android/AndroidContextNotFromKoinTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/android/AndroidContextNotFromKoin.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.android

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class AndroidContextNotFromKoinTest {

    @Test
    fun `reports androidContext in module definition`() {
        val code = """
            val myModule = module {
                single { androidContext() }
            }
        """.trimIndent()

        val findings = AndroidContextNotFromKoin(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("androidContext")
    }

    @Test
    fun `allows androidContext in startKoin block`() {
        val code = """
            class MyApp : Application() {
                override fun onCreate() {
                    startKoin {
                        androidContext(this@MyApp)
                        modules(appModule)
                    }
                }
            }
        """.trimIndent()

        val findings = AndroidContextNotFromKoin(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `reports androidApplication outside startKoin`() {
        val code = """
            val context = androidApplication()
        """.trimIndent()

        val findings = AndroidContextNotFromKoin(Config.empty).lint(code)
        assertThat(findings).hasSize(1)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "AndroidContextNotFromKoinTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.platform.android

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtLambdaExpression
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType

/**
 * Detects `androidContext()` / `androidApplication()` called outside `startKoin`.
 *
 * These should only be set once at app initialization in Application.onCreate.
 * Calling them elsewhere may set wrong context or cause initialization issues.
 *
 * <noncompliant>
 * val myModule = module {
 *     single { androidContext() } // Wrong!
 * }
 * </noncompliant>
 *
 * <compliant>
 * class MyApp : Application() {
 *     override fun onCreate() {
 *         startKoin {
 *             androidContext(this@MyApp)
 *             modules(appModule)
 *         }
 *     }
 * }
 * </compliant>
 */
public class AndroidContextNotFromKoin(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "AndroidContextNotFromKoin",
        severity = Severity.Warning,
        description = "androidContext/androidApplication should only be called in startKoin",
        debt = Debt.FIVE_MINS
    )

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName != "androidContext" && callName != "androidApplication") return

        // Check if inside startKoin lambda
        var current = expression.parent
        var inStartKoin = false
        while (current != null) {
            if (current is KtLambdaExpression) {
                val parentCall = current.parent?.parent as? KtCallExpression
                if (parentCall?.calleeExpression?.text == "startKoin") {
                    inStartKoin = true
                    break
                }
            }
            current = current.parent
        }

        if (!inStartKoin) {
            report(
                CodeSmell(
                    issue,
                    Entity.from(expression),
                    "$callName() should only be called inside startKoin {} block in Application.onCreate. " +
                            "Calling it elsewhere may set wrong context or cause initialization issues."
                )
            )
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "AndroidContextNotFromKoinTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/android/AndroidContextNotFromKoin.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/android/AndroidContextNotFromKoinTest.kt
git commit -m "feat(android): add AndroidContextNotFromKoin rule

Detects androidContext/androidApplication outside startKoin.
Ensures proper Android context initialization.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 8: ActivityFragmentKoinScope - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/platform/android/ActivityFragmentKoinScopeTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/platform/android/ActivityFragmentKoinScope.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.platform.android

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class ActivityFragmentKoinScopeTest {

    @Test
    fun `reports activityScope in Fragment`() {
        val code = """
            class MyFragment : Fragment() {
                val viewModel by activityScope().inject<MyViewModel>()
            }
        """.trimIndent()

        val findings = ActivityFragmentKoinScope(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("activityScope")
        assertThat(findings[0].message).contains("Fragment")
    }

    @Test
    fun `allows fragmentScope in Fragment`() {
        val code = """
            class MyFragment : Fragment() {
                val viewModel by fragmentScope().inject<MyViewModel>()
            }
        """.trimIndent()

        val findings = ActivityFragmentKoinScope(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows activityScope in Activity`() {
        val code = """
            class MyActivity : AppCompatActivity() {
                val viewModel by activityScope().inject<MyViewModel>()
            }
        """.trimIndent()

        val findings = ActivityFragmentKoinScope(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "ActivityFragmentKoinScopeTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.platform.android

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType

/**
 * Detects misuse of `activityScope()` / `fragmentScope()`.
 *
 * Scopes must match component lifecycle. Using wrong scope
 * causes memory leaks or crashes.
 *
 * <noncompliant>
 * class MyFragment : Fragment() {
 *     val vm by activityScope().inject<VM>() // Wrong scope!
 * }
 * </noncompliant>
 *
 * <compliant>
 * class MyFragment : Fragment() {
 *     val vm by fragmentScope().inject<VM>()
 * }
 * </compliant>
 */
public class ActivityFragmentKoinScope(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "ActivityFragmentKoinScope",
        severity = Severity.Warning,
        description = "activityScope/fragmentScope must match component lifecycle",
        debt = Debt.TEN_MINS
    )

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName != "activityScope" && callName != "fragmentScope") return

        val containingClass = expression.getStrictParentOfType<KtClass>() ?: return
        val superTypes = containingClass.getSuperTypeListEntries()
            .mapNotNull { it.typeAsUserType?.referencedName }

        val isFragment = superTypes.any { it.contains("Fragment") }
        val isActivity = superTypes.any { it.contains("Activity") }

        if (isFragment && callName == "activityScope") {
            report(
                CodeSmell(
                    issue,
                    Entity.from(expression),
                    "activityScope() used in Fragment. Use fragmentScope() instead to match Fragment lifecycle."
                )
            )
        } else if (isActivity && callName == "fragmentScope") {
            report(
                CodeSmell(
                    issue,
                    Entity.from(expression),
                    "fragmentScope() used in Activity. Use activityScope() instead to match Activity lifecycle."
                )
            )
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "ActivityFragmentKoinScopeTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/platform/android/ActivityFragmentKoinScope.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/platform/android/ActivityFragmentKoinScopeTest.kt
git commit -m "feat(android): add ActivityFragmentKoinScope rule

Detects wrong scope usage in Activity/Fragment.
Prevents lifecycle mismatches and memory leaks.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 4: Architecture Rules (Days 5-6)

### Task 9: LayerBoundaryViolation - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/architecture/LayerBoundaryViolationTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/architecture/LayerBoundaryViolation.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.TestConfig
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class LayerBoundaryViolationTest {

    @Test
    fun `reports Koin import in domain layer`() {
        val config = TestConfig(
            "restrictedLayers" to listOf("com.example.domain")
        )

        val code = """
            package com.example.domain

            import org.koin.core.component.get

            class UseCase {
                val repo = get<Repository>()
            }
        """.trimIndent()

        val findings = LayerBoundaryViolation(config).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("com.example.domain")
        assertThat(findings[0].message).contains("org.koin.core.component.get")
    }

    @Test
    fun `allows Koin import in unrestricted layer`() {
        val config = TestConfig(
            "restrictedLayers" to listOf("com.example.domain")
        )

        val code = """
            package com.example.data

            import org.koin.core.component.get

            class RepositoryImpl {
                val api = get<ApiService>()
            }
        """.trimIndent()

        val findings = LayerBoundaryViolation(config).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows allowed imports in restricted layer`() {
        val config = TestConfig(
            "restrictedLayers" to listOf("com.example.domain"),
            "allowedImports" to listOf("org.koin.core.qualifier.Qualifier")
        )

        val code = """
            package com.example.domain

            import org.koin.core.qualifier.Qualifier

            class UseCase(qualifier: Qualifier)
        """.trimIndent()

        val findings = LayerBoundaryViolation(config).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `does nothing when restrictedLayers not configured`() {
        val code = """
            package com.example.domain

            import org.koin.core.component.get

            class UseCase
        """.trimIndent()

        val findings = LayerBoundaryViolation(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "LayerBoundaryViolationTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtImportDirective

/**
 * Enforces Clean Architecture by restricting Koin imports in specified layers.
 *
 * Configure restricted layers and optionally allowed imports:
 * ```yaml
 * LayerBoundaryViolation:
 *   active: true
 *   restrictedLayers:
 *     - 'com.example.domain'
 *     - 'com.example.core'
 *   allowedImports:
 *     - 'org.koin.core.qualifier.Qualifier'
 * ```
 *
 * <noncompliant>
 * package com.example.domain
 * import org.koin.core.component.get
 *
 * class UseCase {
 *     val repo = get<Repository>() // Violates Clean Architecture
 * }
 * </noncompliant>
 *
 * <compliant>
 * package com.example.domain
 *
 * class UseCase(
 *     private val repo: Repository // Constructor injection
 * )
 * </compliant>
 */
public class LayerBoundaryViolation(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "LayerBoundaryViolation",
        severity = Severity.Warning,
        description = "Koin imports not allowed in restricted architectural layers",
        debt = Debt.TWENTY_MINS
    )

    private val restrictedLayers: List<String> = valueOrDefault("restrictedLayers", emptyList())
    private val allowedImports: List<String> = valueOrDefault("allowedImports", emptyList())

    override fun visitKtFile(file: KtFile) {
        super.visitKtFile(file)

        if (restrictedLayers.isEmpty()) return

        val packageName = file.packageFqName.asString()
        val isRestricted = restrictedLayers.any { packageName.startsWith(it) }

        if (!isRestricted) return

        file.importDirectives.forEach { directive ->
            checkImport(directive, packageName)
        }
    }

    private fun checkImport(directive: KtImportDirective, packageName: String) {
        val importPath = directive.importPath?.pathStr ?: return

        // Check if it's a Koin import
        if (!importPath.startsWith("org.koin")) return

        // Check if it's in allowed list
        if (allowedImports.any { importPath == it || importPath.startsWith("$it.") }) return

        // Star imports are always violations in restricted layers
        if (directive.isAllUnder) {
            report(
                CodeSmell(
                    issue,
                    Entity.from(directive),
                    "Star import '$importPath.*' not allowed in restricted layer '$packageName'. " +
                            "Domain/Core layers should not depend on Koin."
                )
            )
            return
        }

        // Regular Koin import in restricted layer
        report(
            CodeSmell(
                issue,
                Entity.from(directive),
                "Import '$importPath' not allowed in restricted layer '$packageName'. " +
                        "Domain/Core layers should use constructor injection instead of Koin APIs."
            )
        )
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "LayerBoundaryViolationTest" --no-daemon`
Expected: PASS (4 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/architecture/LayerBoundaryViolation.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/architecture/LayerBoundaryViolationTest.kt
git commit -m "feat(architecture): add LayerBoundaryViolation rule

Enforces Clean Architecture by restricting Koin imports.
Configurable per-project layer definitions.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 10: PlatformImportRestriction - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/architecture/PlatformImportRestrictionTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/architecture/PlatformImportRestriction.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.TestConfig
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class PlatformImportRestrictionTest {

    @Test
    fun `reports Android Koin import in non-Android package`() {
        val config = TestConfig(
            "restrictions" to listOf(
                mapOf(
                    "import" to "org.koin.android.*",
                    "allowedPackages" to listOf("com.example.app")
                )
            )
        )

        val code = """
            package com.example.shared

            import org.koin.android.ext.koin.androidContext

            fun setup() { }
        """.trimIndent()

        val findings = PlatformImportRestriction(config).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("org.koin.android")
        assertThat(findings[0].message).contains("com.example.app")
    }

    @Test
    fun `allows Android Koin import in allowed package`() {
        val config = TestConfig(
            "restrictions" to listOf(
                mapOf(
                    "import" to "org.koin.android.*",
                    "allowedPackages" to listOf("com.example.app")
                )
            )
        )

        val code = """
            package com.example.app

            import org.koin.android.ext.koin.androidContext

            fun setup() { }
        """.trimIndent()

        val findings = PlatformImportRestriction(config).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `does nothing when restrictions not configured`() {
        val code = """
            package com.example.shared

            import org.koin.android.ext.koin.androidContext
        """.trimIndent()

        val findings = PlatformImportRestriction(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "PlatformImportRestrictionTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtImportDirective

/**
 * Restricts platform-specific Koin imports to appropriate modules.
 *
 * Configure import restrictions per platform:
 * ```yaml
 * PlatformImportRestriction:
 *   active: true
 *   restrictions:
 *     - import: 'org.koin.android.*'
 *       allowedPackages: ['com.example.app']
 *     - import: 'org.koin.compose.*'
 *       allowedPackages: ['com.example.ui']
 * ```
 *
 * <noncompliant>
 * package com.example.shared
 * import org.koin.android.ext.koin.androidContext // Wrong!
 * </noncompliant>
 *
 * <compliant>
 * package com.example.app
 * import org.koin.android.ext.koin.androidContext
 * </compliant>
 */
public class PlatformImportRestriction(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "PlatformImportRestriction",
        severity = Severity.Warning,
        description = "Platform-specific imports must be in appropriate modules",
        debt = Debt.TEN_MINS
    )

    private data class ImportRestriction(
        val importPattern: String,
        val allowedPackages: List<String>
    )

    private val restrictions: List<ImportRestriction> = try {
        val rawRestrictions = valueOrDefault<List<Map<String, Any>>>("restrictions", emptyList())
        rawRestrictions.map { map ->
            ImportRestriction(
                importPattern = map["import"] as? String ?: "",
                allowedPackages = (map["allowedPackages"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList()
            )
        }
    } catch (e: Exception) {
        emptyList()
    }

    override fun visitKtFile(file: KtFile) {
        super.visitKtFile(file)

        if (restrictions.isEmpty()) return

        val packageName = file.packageFqName.asString()

        file.importDirectives.forEach { directive ->
            checkImport(directive, packageName)
        }
    }

    private fun checkImport(directive: KtImportDirective, packageName: String) {
        val importPath = directive.importPath?.pathStr ?: return

        restrictions.forEach { restriction ->
            if (matchesPattern(importPath, restriction.importPattern)) {
                val isAllowed = restriction.allowedPackages.any { packageName.startsWith(it) }
                if (!isAllowed) {
                    report(
                        CodeSmell(
                            issue,
                            Entity.from(directive),
                            "Import '$importPath' not allowed in package '$packageName'. " +
                                    "This platform-specific import is only allowed in: ${restriction.allowedPackages.joinToString(", ")}."
                        )
                    )
                }
            }
        }
    }

    private fun matchesPattern(importPath: String, pattern: String): Boolean {
        if (pattern.endsWith(".*")) {
            val prefix = pattern.dropLast(2)
            return importPath.startsWith(prefix)
        }
        return importPath == pattern
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "PlatformImportRestrictionTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/architecture/PlatformImportRestriction.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/architecture/PlatformImportRestrictionTest.kt
git commit -m "feat(architecture): add PlatformImportRestriction rule

Restricts platform-specific imports to appropriate modules.
Prevents accidental platform dependencies in shared code.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 11: CircularModuleDependency - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/architecture/CircularModuleDependencyTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/architecture/CircularModuleDependency.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class CircularModuleDependencyTest {

    @Test
    fun `reports circular dependency between modules`() {
        val code = """
            val moduleA = module {
                includes(moduleB)
            }

            val moduleB = module {
                includes(moduleA)
            }
        """.trimIndent()

        val findings = CircularModuleDependency(Config.empty).lint(code)

        assertThat(findings).hasSize(2) // Both modules reported
        assertThat(findings[0].message).contains("circular")
    }

    @Test
    fun `allows hierarchical module dependencies`() {
        val code = """
            val coreModule = module {
                single { CoreService() }
            }

            val featureModule = module {
                includes(coreModule)
            }
        """.trimIndent()

        val findings = CircularModuleDependency(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `reports self-referencing module`() {
        val code = """
            val module = module {
                includes(module)
            }
        """.trimIndent()

        val findings = CircularModuleDependency(Config.empty).lint(code)
        assertThat(findings).hasSize(1)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "CircularModuleDependencyTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtProperty

/**
 * Detects circular dependencies between Koin modules via `includes()`.
 *
 * Circular module dependencies cause initialization issues and make
 * dependency graph hard to understand.
 *
 * <noncompliant>
 * val moduleA = module {
 *     includes(moduleB)
 * }
 *
 * val moduleB = module {
 *     includes(moduleA) // Circular!
 * }
 * </noncompliant>
 *
 * <compliant>
 * val coreModule = module { }
 * val featureModule = module {
 *     includes(coreModule)
 * }
 * </compliant>
 */
public class CircularModuleDependency(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "CircularModuleDependency",
        severity = Severity.Warning,
        description = "Circular dependency between Koin modules",
        debt = Debt.TWENTY_MINS
    )

    private val moduleDependencies = mutableMapOf<String, MutableSet<String>>()

    override fun visitKtFile(file: KtFile) {
        moduleDependencies.clear()
        super.visitKtFile(file)
        checkForCycles()
    }

    override fun visitProperty(property: KtProperty) {
        super.visitProperty(property)

        val moduleName = property.name ?: return
        val initializer = property.initializer as? KtCallExpression ?: return

        if (initializer.calleeExpression?.text == "module") {
            val includes = findIncludes(initializer)
            if (includes.isNotEmpty()) {
                moduleDependencies.getOrPut(moduleName) { mutableSetOf() }.addAll(includes)
            }
        }
    }

    private fun findIncludes(moduleCall: KtCallExpression): Set<String> {
        val includes = mutableSetOf<String>()

        moduleCall.accept(object : org.jetbrains.kotlin.psi.KtTreeVisitorVoid() {
            override fun visitCallExpression(expression: KtCallExpression) {
                super.visitCallExpression(expression)

                if (expression.calleeExpression?.text == "includes") {
                    expression.valueArguments.forEach { arg ->
                        arg.getArgumentExpression()?.text?.let { includes.add(it) }
                    }
                }
            }
        })

        return includes
    }

    private fun checkForCycles() {
        val visited = mutableSetOf<String>()
        val recStack = mutableSetOf<String>()

        fun hasCycle(module: String): Boolean {
            if (recStack.contains(module)) {
                reportCycle(module)
                return true
            }
            if (visited.contains(module)) return false

            visited.add(module)
            recStack.add(module)

            moduleDependencies[module]?.forEach { dependency ->
                if (hasCycle(dependency)) return true
            }

            recStack.remove(module)
            return false
        }

        moduleDependencies.keys.forEach { module ->
            if (!visited.contains(module)) {
                hasCycle(module)
            }
        }
    }

    private fun reportCycle(moduleName: String) {
        // Find the property to report on
        // This is simplified - in real implementation would track PSI elements
        report(
            CodeSmell(
                issue,
                Entity.atPackageOrFirstDecl(bindingContext.get(BindingContext.FILE_TO_PACKAGE_FRAGMENT_MAP, ktFile)?.ktFile ?: ktFile),
                "Module '$moduleName' participates in circular dependency. " +
                        "Circular module dependencies make initialization order undefined."
            )
        )
    }
}
```

**Note:** The above implementation is simplified. For production, we'd need to track PSI elements during traversal. Let me provide a more practical implementation:

```kotlin
package io.github.krozov.detekt.koin.architecture

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtTreeVisitorVoid

/**
 * Detects circular dependencies between Koin modules via `includes()`.
 */
public class CircularModuleDependency(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "CircularModuleDependency",
        severity = Severity.Warning,
        description = "Circular dependency between Koin modules",
        debt = Debt.TWENTY_MINS
    )

    private data class ModuleInfo(
        val name: String,
        val property: KtProperty,
        val dependencies: Set<String>
    )

    private val modules = mutableListOf<ModuleInfo>()

    override fun visitKtFile(file: KtFile) {
        modules.clear()
        super.visitKtFile(file)
        checkForCycles()
    }

    override fun visitProperty(property: KtProperty) {
        super.visitProperty(property)

        val moduleName = property.name ?: return
        val initializer = property.initializer as? KtCallExpression ?: return

        if (initializer.calleeExpression?.text == "module") {
            val includes = findIncludes(initializer)
            modules.add(ModuleInfo(moduleName, property, includes))
        }
    }

    private fun findIncludes(moduleCall: KtCallExpression): Set<String> {
        val includes = mutableSetOf<String>()

        moduleCall.accept(object : KtTreeVisitorVoid() {
            override fun visitCallExpression(expression: KtCallExpression) {
                super.visitCallExpression(expression)

                if (expression.calleeExpression?.text == "includes") {
                    expression.valueArguments.forEach { arg ->
                        arg.getArgumentExpression()?.text?.let { includes.add(it) }
                    }
                }
            }
        })

        return includes
    }

    private fun checkForCycles() {
        modules.forEach { module ->
            // Check for self-reference
            if (module.dependencies.contains(module.name)) {
                report(
                    CodeSmell(
                        issue,
                        Entity.from(module.property),
                        "Module '${module.name}' includes itself. Remove self-reference."
                    )
                )
            }

            // Check for direct circular dependency
            module.dependencies.forEach { depName ->
                val dependency = modules.find { it.name == depName }
                if (dependency != null && dependency.dependencies.contains(module.name)) {
                    report(
                        CodeSmell(
                            issue,
                            Entity.from(module.property),
                            "Circular dependency between modules '${module.name}' and '$depName'. " +
                                    "Refactor to hierarchical dependency structure."
                        )
                    )
                }
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "CircularModuleDependencyTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/architecture/CircularModuleDependency.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/architecture/CircularModuleDependencyTest.kt
git commit -m "feat(architecture): add CircularModuleDependency rule

Detects circular dependencies via includes().
Ensures clean module hierarchy.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 5: Integration & RuleSetProvider Update (Day 7)

### Task 12: Update KoinRuleSetProvider with New Rules

**Files:**
- Modify: `src/main/kotlin/io/github/krozov/detekt/koin/KoinRuleSetProvider.kt`

**Step 1: Read current provider**

Run: Check current file to understand structure
```bash
cat src/main/kotlin/io/github/krozov/detekt/koin/KoinRuleSetProvider.kt
```

**Step 2: Add new rule imports and registrations**

Add imports at top:
```kotlin
// Platform rules - Compose
import io.github.krozov.detekt.koin.platform.compose.KoinViewModelOutsideComposable
import io.github.krozov.detekt.koin.platform.compose.KoinInjectInPreview
import io.github.krozov.detekt.koin.platform.compose.RememberKoinModulesLeak

// Platform rules - Ktor
import io.github.krozov.detekt.koin.platform.ktor.KtorApplicationKoinInit
import io.github.krozov.detekt.koin.platform.ktor.KtorRouteScopeMisuse

// Platform rules - Android
import io.github.krozov.detekt.koin.platform.android.AndroidContextNotFromKoin
import io.github.krozov.detekt.koin.platform.android.ActivityFragmentKoinScope

// Architecture rules
import io.github.krozov.detekt.koin.architecture.LayerBoundaryViolation
import io.github.krozov.detekt.koin.architecture.PlatformImportRestriction
import io.github.krozov.detekt.koin.architecture.CircularModuleDependency
```

Add rules to RuleSet:
```kotlin
override fun instance(config: Config): RuleSet {
    return RuleSet(
        ruleSetId,
        listOf(
            // Existing Service Locator rules
            NoGetOutsideModuleDefinition(config),
            NoInjectDelegate(config),
            NoKoinComponentInterface(config),
            NoGlobalContextAccess(config),
            NoKoinGetInApplication(config),

            // Existing Module DSL rules
            EmptyModule(config),
            SingleForNonSharedDependency(config),
            MissingScopedDependencyQualifier(config),
            DeprecatedKoinApi(config),
            ModuleIncludesOrganization(config),

            // Existing Scope rules
            MissingScopeClose(config),
            ScopedDependencyOutsideScopeBlock(config),
            FactoryInScopeBlock(config),
            KtorRequestScopeMisuse(config),

            // NEW Platform rules - Compose
            KoinViewModelOutsideComposable(config),
            KoinInjectInPreview(config),
            RememberKoinModulesLeak(config),

            // NEW Platform rules - Ktor
            KtorApplicationKoinInit(config),
            KtorRouteScopeMisuse(config),

            // NEW Platform rules - Android
            AndroidContextNotFromKoin(config),
            ActivityFragmentKoinScope(config),

            // NEW Architecture rules
            LayerBoundaryViolation(config),
            PlatformImportRestriction(config),
            CircularModuleDependency(config)
        )
    )
}
```

**Step 3: Run tests to verify all rules load**

Run: `./gradlew test --tests "KoinRulesIntegrationTest" --no-daemon`
Expected: MAY FAIL - integration test expects 14 rules, now we have 24

**Step 4: Update integration test**

Modify: `src/test/kotlin/io/github/krozov/detekt/koin/integration/KoinRulesIntegrationTest.kt`

Update test:
```kotlin
assertThat(ruleSet.rules).hasSize(24) // Changed from 14

// Update rule IDs list
val ruleIds = ruleSet.rules.map { it.ruleId }
assertThat(ruleIds).containsExactlyInAnyOrder(
    // Existing rules...
    "NoGetOutsideModuleDefinition",
    "NoInjectDelegate",
    "NoKoinComponentInterface",
    "NoGlobalContextAccess",
    "NoKoinGetInApplication",
    "EmptyModule",
    "SingleForNonSharedDependency",
    "MissingScopedDependencyQualifier",
    "DeprecatedKoinApi",
    "ModuleIncludesOrganization",
    "MissingScopeClose",
    "ScopedDependencyOutsideScopeBlock",
    "FactoryInScopeBlock",
    "KtorRequestScopeMisuse",

    // New Compose rules
    "KoinViewModelOutsideComposable",
    "KoinInjectInPreview",
    "RememberKoinModulesLeak",

    // New Ktor rules
    "KtorApplicationKoinInit",
    "KtorRouteScopeMisuse",

    // New Android rules
    "AndroidContextNotFromKoin",
    "ActivityFragmentKoinScope",

    // New Architecture rules
    "LayerBoundaryViolation",
    "PlatformImportRestriction",
    "CircularModuleDependency"
)
```

**Step 5: Run all tests**

Run: `./gradlew test --no-daemon`
Expected: PASS (all 205+ tests)

**Step 6: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/KoinRuleSetProvider.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/integration/KoinRulesIntegrationTest.kt
git commit -m "feat: register 10 new rules in KoinRuleSetProvider

Add to RuleSet:
- 3 Compose rules
- 2 Ktor rules
- 2 Android rules
- 3 Architecture rules

Total rules: 14  24

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 6: Documentation (Days 8-9)

### Task 13: Update docs/rules.md

**Files:**
- Modify: `docs/rules.md`

**Step 1: Add Platform Rules section**

Add after existing sections:

```markdown
## Platform Rules

### Compose Rules

#### KoinViewModelOutsideComposable

**Severity:** Warning
**Active:** Yes

Detects `koinViewModel()` calls outside `@Composable` functions.

 **Bad:**
```kotlin
fun MyScreen() {
    val vm = koinViewModel<MyVM>() // Runtime crash!
}
```

 **Good:**
```kotlin
@Composable
fun MyScreen() {
    val vm = koinViewModel<MyVM>()
}
```

**Edge Cases:**
-  Detects in init blocks and properties
-  Works with inline Composable functions
-  Handles qualified koinViewModel calls

---

#### KoinInjectInPreview

**Severity:** Warning
**Active:** Yes

Detects `koinInject()` in `@Preview` functions.

 **Bad:**
```kotlin
@Preview
@Composable
fun MyScreenPreview() {
    val repo = koinInject<Repository>() // Preview crash!
    MyScreen(repo)
}
```

 **Good:**
```kotlin
@Preview
@Composable
fun MyScreenPreview() {
    MyScreen(FakeRepository())
}
```

---

#### RememberKoinModulesLeak

**Severity:** Warning
**Active:** Yes

Detects `loadKoinModules()` inside `remember {}` without unload.

 **Bad:**
```kotlin
@Composable
fun FeatureScreen() {
    remember { loadKoinModules(featureModule) } // Memory leak!
}
```

 **Good:**
```kotlin
@Composable
fun FeatureScreen() {
    DisposableEffect(Unit) {
        loadKoinModules(featureModule)
        onDispose { unloadKoinModules(featureModule) }
    }
}
```

---

### Ktor Rules

#### KtorApplicationKoinInit

**Severity:** Warning
**Active:** Yes

Detects `install(Koin)` in routing blocks or route handlers.

 **Bad:**
```kotlin
fun Application.module() {
    routing {
        install(Koin) { } // Wrong place!
        get("/api") { }
    }
}
```

 **Good:**
```kotlin
fun Application.module() {
    install(Koin) { }
    routing {
        get("/api") { }
    }
}
```

---

#### KtorRouteScopeMisuse

**Severity:** Warning
**Active:** Yes

Detects shared `koinScope()` across HTTP requests.

 **Bad:**
```kotlin
val sharedScope = koinScope() // Shared across requests!
get("/api") {
    val service = sharedScope.get<Service>()
}
```

 **Good:**
```kotlin
get("/api") {
    call.koinScope().get<Service>() // Request-scoped
}
```

---

### Android Rules

#### AndroidContextNotFromKoin

**Severity:** Warning
**Active:** Yes

Detects `androidContext()` / `androidApplication()` called outside `startKoin`.

 **Bad:**
```kotlin
val module = module {
    single { androidContext() } // Wrong context!
}
```

 **Good:**
```kotlin
class MyApp : Application() {
    override fun onCreate() {
        startKoin {
            androidContext(this@MyApp)
            modules(appModule)
        }
    }
}
```

---

#### ActivityFragmentKoinScope

**Severity:** Warning
**Active:** Yes

Detects misuse of `activityScope()` / `fragmentScope()`.

 **Bad:**
```kotlin
class MyFragment : Fragment() {
    val vm by activityScope().inject<VM>() // Wrong scope!
}
```

 **Good:**
```kotlin
class MyFragment : Fragment() {
    val vm by fragmentScope().inject<VM>()
}
```

---

## Architecture Rules

### LayerBoundaryViolation

**Severity:** Warning
**Active:** No (opt-in)

Enforces Clean Architecture by restricting Koin imports in specified layers.

**Configuration:**
```yaml
LayerBoundaryViolation:
  active: true
  restrictedLayers:
    - 'com.example.domain'
    - 'com.example.core'
  allowedImports:
    - 'org.koin.core.qualifier.Qualifier'
```

 **Bad:**
```kotlin
package com.example.domain
import org.koin.core.component.get

class UseCase {
    val repo = get<Repository>() // Violates Clean Architecture!
}
```

 **Good:**
```kotlin
package com.example.domain

class UseCase(
    private val repo: Repository // Constructor injection
)
```

---

### PlatformImportRestriction

**Severity:** Warning
**Active:** No (opt-in)

Restricts platform-specific Koin imports to appropriate modules.

**Configuration:**
```yaml
PlatformImportRestriction:
  active: true
  restrictions:
    - import: 'org.koin.android.*'
      allowedPackages: ['com.example.app']
    - import: 'org.koin.compose.*'
      allowedPackages: ['com.example.ui']
```

 **Bad:**
```kotlin
package com.example.shared
import org.koin.android.ext.koin.androidContext // Wrong!
```

 **Good:**
```kotlin
package com.example.app
import org.koin.android.ext.koin.androidContext
```

---

### CircularModuleDependency

**Severity:** Warning
**Active:** Yes

Detects circular dependencies between Koin modules via `includes()`.

 **Bad:**
```kotlin
val moduleA = module {
    includes(moduleB)
}

val moduleB = module {
    includes(moduleA) // Circular!
}
```

 **Good:**
```kotlin
val coreModule = module { }
val featureModule = module {
    includes(coreModule)
}
```
```

**Step 2: Update README.md rule count**

Modify: `README.md`

Change:
```markdown
Detekt 1.x extension library with 14 rules for Koin 4.x
```

To:
```markdown
Detekt 1.x extension library with 24 rules for Koin 4.x
```

Update table counts:
- Service Locator Rules: 5 (unchanged)
- Module DSL Rules: 5 (unchanged)
- Scope Management Rules: 4 (unchanged)
- **Platform Rules: 7 (NEW)**
- **Architecture Rules: 3 (NEW)**

**Step 3: Commit documentation**

```bash
git add docs/rules.md README.md
git commit -m "docs: add documentation for 10 new rules

Document all new rules:
- 3 Compose rules
- 2 Ktor rules
- 2 Android rules
- 3 Architecture rules

Update README rule count: 14  24

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 7: Final Verification (Day 10)

### Task 14: Coverage Verification

**Step 1: Run full test suite**

Run: `./gradlew clean test --no-daemon`
Expected: PASS (205+ tests)

**Step 2: Generate coverage report**

Run: `./gradlew koverHtmlReport`

**Step 3: Verify coverage meets thresholds**

Run: `./gradlew koverVerify`
Expected: PASS (98% line, 70% branch)

Check: `open build/reports/kover/html/index.html`
Verify: Line coverage  98%, Branch coverage  70%

**Step 4: If coverage fails, add missing tests**

If coverage < 98%/70%, identify uncovered code:
- Check coverage report for uncovered lines
- Add edge case tests for uncovered branches
- Repeat until coverage meets threshold

---

### Task 15: Build Verification

**Step 1: Clean build**

Run: `./gradlew clean`

**Step 2: Full build with all checks**

Run: `./gradlew build --no-daemon`
Expected: BUILD SUCCESSFUL

Verify:
-  Compilation successful (no warnings)
-  All tests pass (205+ tests)
-  Coverage verification passes
-  JARs built successfully

**Step 3: Verify artifacts**

Check: `ls -lh build/libs/`
Expected: 3 JARs (main, sources, javadoc)

---

### Task 16: Update version and create release tag

**Files:**
- Modify: `build.gradle.kts`

**Step 1: Update version**

Change:
```kotlin
version = "0.1.0"
```

To:
```kotlin
version = "0.2.0"
```

**Step 2: Commit version bump**

```bash
git add build.gradle.kts
git commit -m "chore: bump version to 0.2.0

Release highlights:
- 10 new rules (7 platform + 3 architecture)
- Compose, Ktor, Android platform support
- Clean Architecture boundary validation
- 205+ tests, 98%/70% coverage maintained

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**Step 3: Create git tag**

Run: `git tag -a v0.2.0 -m "Release v0.2.0: Platform & Architecture Rules"`

**Step 4: Push with tags**

Run: `git push origin main --tags`

---

## Success Criteria

 **10 new rules implemented:**
- 3 Compose rules
- 2 Ktor rules
- 2 Android rules
- 3 Architecture rules

 **Test coverage:**
- 50+ new tests added
- Total tests: 155  205+
- Line coverage: 98%+
- Branch coverage: 70%+

 **Documentation:**
- docs/rules.md updated with all new rules
- README.md updated (14  24 rules)
- All rules have examples and edge cases

 **Quality:**
- All tests passing
- Zero warnings (allWarningsAsErrors)
- Build successful
- CI/CD green

 **Release:**
- Version bumped to 0.2.0
- Git tag created
- Ready for Maven Central publish

---

## Timeline

- **Days 1-2:** Compose rules (Tasks 1-4)
- **Day 3:** Ktor rules (Tasks 5-6)
- **Day 4:** Android rules (Tasks 7-8)
- **Days 5-6:** Architecture rules (Tasks 9-11)
- **Day 7:** Integration & RuleSetProvider (Task 12)
- **Days 8-9:** Documentation (Task 13)
- **Day 10:** Final verification & release (Tasks 14-16)

**Total: 10 working days (~2 weeks)**

---

## Next Steps (After v0.2.0)

See design document for v0.3.0 and v0.4.0 planning:
- v0.3.0: Koin Annotations + DX foundations
- v0.4.0: Auto-fixes + advanced configuration
