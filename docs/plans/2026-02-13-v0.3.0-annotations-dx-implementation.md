# v0.3.0 Koin Annotations + DX Foundations Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add 5 Koin Annotations rules + DX foundations (suppression support, enhanced messages) for all 29 rules

**Architecture:** Expand with new annotations/ package for Koin Annotations support. Enhance all existing rules with suppression and better messages. Maintain 98%/70% coverage.

**Tech Stack:** Kotlin 2.0, Detekt 1.23.8+, JUnit 5, AssertJ, Kover

**Design Document:** [docs/plans/2026-02-13-detekt-koin-v0.2-v0.4-expansion-design.md](./2026-02-13-detekt-koin-v0.2-v0.4-expansion-design.md)

**Previous Version:** v0.2.0 (24 rules implemented)

---

## Overview

**v0.3.0 adds:**
- 5 new Koin Annotations rules
- Suppression support (`@Suppress`) for all 29 rules
- Enhanced error messages with examples for all rules
- Configuration improvements

**Timeline:** 2-3 weeks
- Week 1: Annotation rules (5 rules)
- Week 2: DX foundations (suppression + messages)
- Week 3: Integration, testing, release

---

## Phase 1: Koin Annotations Rules (Week 1, Days 1-5)

### Task 1: MixingDslAndAnnotations - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/annotations/MixingDslAndAnnotationsTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/annotations/MixingDslAndAnnotations.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class MixingDslAndAnnotationsTest {

    @Test
    fun `reports mixing DSL and Annotations in same file`() {
        val code = """
            import org.koin.core.annotation.Module
            import org.koin.core.annotation.Single
            import org.koin.dsl.module

            @Module
            class AnnotatedModule {
                @Single
                fun provideRepo(): Repository = RepositoryImpl()
            }

            val dslModule = module {
                single { ApiService() }
            }
        """.trimIndent()

        val findings = MixingDslAndAnnotations(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("mixing")
        assertThat(findings[0].message).contains("DSL")
        assertThat(findings[0].message).contains("Annotations")
    }

    @Test
    fun `allows DSL only`() {
        val code = """
            import org.koin.dsl.module

            val module = module {
                single { Service() }
            }
        """.trimIndent()

        val findings = MixingDslAndAnnotations(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows Annotations only`() {
        val code = """
            import org.koin.core.annotation.Module
            import org.koin.core.annotation.Single

            @Module
            class MyModule {
                @Single
                fun provideService(): Service = ServiceImpl()
            }
        """.trimIndent()

        val findings = MixingDslAndAnnotations(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "MixingDslAndAnnotationsTest" --no-daemon`
Expected: FAIL with "MixingDslAndAnnotations class not found"

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtFile

/**
 * Detects mixing DSL (`module {}`) and Annotations (`@Module`, `@Single`) in same file.
 *
 * Mixing both approaches in the same file is inconsistent and harder to maintain.
 * Choose one approach per file.
 *
 * <noncompliant>
 * @Module
 * class AnnotatedModule {
 *     @Single
 *     fun provideRepo(): Repository = ...
 * }
 *
 * val dslModule = module {
 *     single { ApiService() }
 * }
 * </noncompliant>
 *
 * <compliant>
 * // Either all DSL:
 * val module = module {
 *     single { Repository() }
 *     single { ApiService() }
 * }
 *
 * // Or all Annotations:
 * @Module
 * class MyModule {
 *     @Single
 *     fun provideRepo(): Repository = ...
 *     @Single
 *     fun provideApi(): ApiService = ...
 * }
 * </compliant>
 */
public class MixingDslAndAnnotations(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "MixingDslAndAnnotations",
        severity = Severity.Warning,
        description = "Mixing DSL and Annotations in same file is inconsistent",
        debt = Debt.FIVE_MINS
    )

    private var hasModuleCall = false
    private var hasModuleAnnotation = false
    private var moduleCallElement: KtCallExpression? = null

    override fun visitKtFile(file: KtFile) {
        hasModuleCall = false
        hasModuleAnnotation = false
        moduleCallElement = null

        // Check for Koin annotations
        file.declarations.forEach { declaration ->
            val annotations = declaration.annotationEntries.mapNotNull { it.shortName?.asString() }
            if ("Module" in annotations || "Single" in annotations || "Factory" in annotations) {
                hasModuleAnnotation = true
            }
        }

        super.visitKtFile(file)

        // Report if mixing both
        if (hasModuleCall && hasModuleAnnotation && moduleCallElement != null) {
            report(
                CodeSmell(
                    issue,
                    Entity.from(moduleCallElement!!),
                    "Mixing DSL (module {}) and Annotations (@Module, @Single) in same file. " +
                            "Choose one approach for consistency."
                )
            )
        }
    }

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName == "module") {
            hasModuleCall = true
            if (moduleCallElement == null) {
                moduleCallElement = expression
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "MixingDslAndAnnotationsTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/annotations/MixingDslAndAnnotations.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/annotations/MixingDslAndAnnotationsTest.kt
git commit -m "feat(annotations): add MixingDslAndAnnotations rule

Detects mixing DSL and Annotations in same file.
Encourages consistent approach per file.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 2: MissingModuleAnnotation - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/annotations/MissingModuleAnnotationTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/annotations/MissingModuleAnnotation.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class MissingModuleAnnotationTest {

    @Test
    fun `reports Single without Module annotation`() {
        val code = """
            import org.koin.core.annotation.Single

            class MyServices {
                @Single
                fun provideRepo(): Repository = RepositoryImpl()
            }
        """.trimIndent()

        val findings = MissingModuleAnnotation(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("@Module")
        assertThat(findings[0].message).contains("@Single")
    }

    @Test
    fun `allows Single with Module annotation`() {
        val code = """
            import org.koin.core.annotation.Module
            import org.koin.core.annotation.Single

            @Module
            class MyServices {
                @Single
                fun provideRepo(): Repository = RepositoryImpl()
            }
        """.trimIndent()

        val findings = MissingModuleAnnotation(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `reports Factory without Module annotation`() {
        val code = """
            import org.koin.core.annotation.Factory

            class MyServices {
                @Factory
                fun createService(): Service = ServiceImpl()
            }
        """.trimIndent()

        val findings = MissingModuleAnnotation(Config.empty).lint(code)
        assertThat(findings).hasSize(1)
    }

    @Test
    fun `allows class without Koin annotations`() {
        val code = """
            class MyServices {
                fun provideRepo(): Repository = RepositoryImpl()
            }
        """.trimIndent()

        val findings = MissingModuleAnnotation(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "MissingModuleAnnotationTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtClass

/**
 * Class has `@Single`/`@Factory` but no `@Module` annotation.
 *
 * Annotation processor won't find definitions without `@Module`.
 *
 * <noncompliant>
 * class MyServices {
 *     @Single
 *     fun provideRepo(): Repository = ... // Won't be discovered!
 * }
 * </noncompliant>
 *
 * <compliant>
 * @Module
 * class MyServices {
 *     @Single
 *     fun provideRepo(): Repository = ...
 * }
 * </compliant>
 */
public class MissingModuleAnnotation(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "MissingModuleAnnotation",
        severity = Severity.Warning,
        description = "Class with @Single/@Factory needs @Module annotation",
        debt = Debt.FIVE_MINS
    )

    override fun visitClass(klass: KtClass) {
        super.visitClass(klass)

        val classAnnotations = klass.annotationEntries.mapNotNull { it.shortName?.asString() }
        val hasModuleAnnotation = "Module" in classAnnotations

        if (!hasModuleAnnotation) {
            // Check if class has methods with Koin annotations
            val hasKoinDefinitions = klass.declarations.any { declaration ->
                val annotations = declaration.annotationEntries.mapNotNull { it.shortName?.asString() }
                annotations.any { it in setOf("Single", "Factory", "Scoped") }
            }

            if (hasKoinDefinitions) {
                report(
                    CodeSmell(
                        issue,
                        Entity.from(klass),
                        "Class '${klass.name}' has @Single/@Factory/@Scoped but no @Module annotation. " +
                                "Annotation processor won't discover these definitions without @Module."
                    )
                )
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "MissingModuleAnnotationTest" --no-daemon`
Expected: PASS (4 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/annotations/MissingModuleAnnotation.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/annotations/MissingModuleAnnotationTest.kt
git commit -m "feat(annotations): add MissingModuleAnnotation rule

Detects @Single/@Factory without @Module.
Prevents definitions from being missed by annotation processor.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 3: ConflictingBindings - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/annotations/ConflictingBindingsTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/annotations/ConflictingBindings.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class ConflictingBindingsTest {

    @Test
    fun `reports same type in DSL and Annotations`() {
        val code = """
            import org.koin.core.annotation.Module
            import org.koin.core.annotation.Single
            import org.koin.dsl.module

            @Module
            class AnnotatedModule {
                @Single
                fun provideRepo(): Repository = RepositoryImpl()
            }

            val dslModule = module {
                single<Repository> { RepositoryImpl() }
            }
        """.trimIndent()

        val findings = ConflictingBindings(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("Repository")
        assertThat(findings[0].message).contains("conflict")
    }

    @Test
    fun `allows different types`() {
        val code = """
            import org.koin.core.annotation.Module
            import org.koin.core.annotation.Single
            import org.koin.dsl.module

            @Module
            class AnnotatedModule {
                @Single
                fun provideRepo(): Repository = RepositoryImpl()
            }

            val dslModule = module {
                single { ApiService() }
            }
        """.trimIndent()

        val findings = ConflictingBindings(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows same type with different qualifiers`() {
        val code = """
            import org.koin.core.annotation.Module
            import org.koin.core.annotation.Single
            import org.koin.core.annotation.Named
            import org.koin.dsl.module
            import org.koin.core.qualifier.named

            @Module
            class AnnotatedModule {
                @Single
                @Named("impl1")
                fun provideRepo1(): Repository = RepositoryImpl1()
            }

            val dslModule = module {
                single(named("impl2")) { Repository2() as Repository }
            }
        """.trimIndent()

        val findings = ConflictingBindings(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "ConflictingBindingsTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtNamedFunction

/**
 * Same type defined in both DSL and Annotations.
 *
 * Runtime conflict - which definition wins?
 *
 * <noncompliant>
 * @Module
 * class AnnotatedModule {
 *     @Single
 *     fun provideRepo(): Repository = RepoImpl()
 * }
 *
 * val dslModule = module {
 *     single<Repository> { RepoImpl() } // Conflict!
 * }
 * </noncompliant>
 *
 * <compliant>
 * // Choose one approach:
 * @Module
 * class AnnotatedModule {
 *     @Single
 *     fun provideRepo(): Repository = RepoImpl()
 * }
 * </compliant>
 */
public class ConflictingBindings(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "ConflictingBindings",
        severity = Severity.Error,
        description = "Same type defined in both DSL and Annotations",
        debt = Debt.TEN_MINS
    )

    private val annotatedTypes = mutableSetOf<String>()
    private val dslTypes = mutableSetOf<String>()
    private val typeToElement = mutableMapOf<String, Any>()

    override fun visitKtFile(file: KtFile) {
        annotatedTypes.clear()
        dslTypes.clear()
        typeToElement.clear()

        super.visitKtFile(file)

        // Find conflicts
        val conflicts = annotatedTypes.intersect(dslTypes)
        conflicts.forEach { type ->
            typeToElement[type]?.let { element ->
                report(
                    CodeSmell(
                        issue,
                        Entity.from(element as org.jetbrains.kotlin.psi.KtElement),
                        "Type '$type' defined in both DSL and Annotations. " +
                                "This creates a runtime conflict. Use only one approach."
                    )
                )
            }
        }
    }

    override fun visitNamedFunction(function: KtNamedFunction) {
        super.visitNamedFunction(function)

        val annotations = function.annotationEntries.mapNotNull { it.shortName?.asString() }
        if (annotations.any { it in setOf("Single", "Factory", "Scoped") }) {
            val returnType = function.typeReference?.text
            if (returnType != null) {
                val typeName = returnType.substringBefore("<").substringAfterLast(".")
                annotatedTypes.add(typeName)
                if (typeName !in typeToElement) {
                    typeToElement[typeName] = function
                }
            }
        }
    }

    override fun visitCallExpression(expression: KtCallExpression) {
        super.visitCallExpression(expression)

        val callName = expression.calleeExpression?.text ?: return
        if (callName in setOf("single", "factory", "scoped")) {
            // Try to extract type from type argument
            val typeArgs = expression.typeArgumentList?.arguments
            val typeName = typeArgs?.firstOrNull()?.typeReference?.text
                ?.substringBefore("<")
                ?.substringAfterLast(".")

            if (typeName != null) {
                dslTypes.add(typeName)
                if (typeName !in typeToElement) {
                    typeToElement[typeName] = expression
                }
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "ConflictingBindingsTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/annotations/ConflictingBindings.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/annotations/ConflictingBindingsTest.kt
git commit -m "feat(annotations): add ConflictingBindings rule

Detects same type in DSL and Annotations.
Prevents runtime conflicts.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 4: ScopedWithoutQualifier - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/annotations/ScopedWithoutQualifierTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/annotations/ScopedWithoutQualifier.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class ScopedWithoutQualifierTest {

    @Test
    fun `reports Scoped without name`() {
        val code = """
            import org.koin.core.annotation.Scoped

            @Scoped
            class MyService
        """.trimIndent()

        val findings = ScopedWithoutQualifier(Config.empty).lint(code)

        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("@Scoped")
        assertThat(findings[0].message).contains("qualifier")
    }

    @Test
    fun `allows Scoped with name`() {
        val code = """
            import org.koin.core.annotation.Scoped

            @Scoped(name = "userScope")
            class MyService
        """.trimIndent()

        val findings = ScopedWithoutQualifier(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `allows Single and Factory`() {
        val code = """
            import org.koin.core.annotation.Single
            import org.koin.core.annotation.Factory

            @Single
            class SingleService

            @Factory
            class FactoryService
        """.trimIndent()

        val findings = ScopedWithoutQualifier(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "ScopedWithoutQualifierTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtClass

/**
 * `@Scoped` without scope name/qualifier.
 *
 * Default scope may be unclear, better to be explicit.
 *
 * <noncompliant>
 * @Scoped
 * class MyService // Which scope?
 * </noncompliant>
 *
 * <compliant>
 * @Scoped(name = "userScope")
 * class MyService
 * </compliant>
 */
public class ScopedWithoutQualifier(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "ScopedWithoutQualifier",
        severity = Severity.Warning,
        description = "@Scoped should specify scope name for clarity",
        debt = Debt.FIVE_MINS
    )

    override fun visitClass(klass: KtClass) {
        super.visitClass(klass)

        val scopedAnnotation = klass.annotationEntries.find {
            it.shortName?.asString() == "Scoped"
        }

        if (scopedAnnotation != null) {
            // Check if annotation has parameters
            val hasParameters = scopedAnnotation.valueArgumentList != null &&
                    scopedAnnotation.valueArgumentList!!.arguments.isNotEmpty()

            if (!hasParameters) {
                report(
                    CodeSmell(
                        issue,
                        Entity.from(scopedAnnotation),
                        "@Scoped annotation should specify scope name (e.g., @Scoped(name = \"userScope\")). " +
                                "Default scope may be unclear."
                    )
                )
            }
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "ScopedWithoutQualifierTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/annotations/ScopedWithoutQualifier.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/annotations/ScopedWithoutQualifierTest.kt
git commit -m "feat(annotations): add ScopedWithoutQualifier rule

Detects @Scoped without scope name.
Encourages explicit scope naming.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 5: AnnotationProcessorNotConfigured - Implementation

**Files:**
- Create: `src/test/kotlin/io/github/krozov/detekt/koin/annotations/AnnotationProcessorNotConfiguredTest.kt`
- Create: `src/main/kotlin/io/github/krozov/detekt/koin/annotations/AnnotationProcessorNotConfigured.kt`

**Step 1: Write the failing test**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.TestConfig
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class AnnotationProcessorNotConfiguredTest {

    @Test
    fun `reports @Single without generated code check (info level)`() {
        val code = """
            import org.koin.core.annotation.Single

            @Single
            class MyService
        """.trimIndent()

        val findings = AnnotationProcessorNotConfigured(Config.empty).lint(code)

        // This rule provides info-level message since we can't reliably detect
        // if annotation processor is configured in Detekt context
        assertThat(findings).hasSize(1)
        assertThat(findings[0].message).contains("annotation processor")
    }

    @Test
    fun `allows regular classes`() {
        val code = """
            class MyService
        """.trimIndent()

        val findings = AnnotationProcessorNotConfigured(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `can be configured to skip check`() {
        val config = TestConfig(
            "skipCheck" to true
        )

        val code = """
            import org.koin.core.annotation.Single

            @Single
            class MyService
        """.trimIndent()

        val findings = AnnotationProcessorNotConfigured(config).lint(code)
        assertThat(findings).isEmpty()
    }
}
```

**Step 2: Run test to verify it fails**

Run: `./gradlew test --tests "AnnotationProcessorNotConfiguredTest" --no-daemon`
Expected: FAIL

**Step 3: Implement rule**

```kotlin
package io.github.krozov.detekt.koin.annotations

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Debt
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Issue
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.Severity
import org.jetbrains.kotlin.psi.KtClass

/**
 * Uses `@Single`/`@Factory` but KSP/KAPT may not be configured.
 *
 * Note: This rule provides informational warnings since Detekt cannot
 * reliably detect if annotation processor is configured in the build.
 *
 * <noncompliant>
 * // build.gradle.kts missing:
 * // plugins { id("com.google.devtools.ksp") }
 * // dependencies { ksp("io.insert-koin:koin-ksp-compiler") }
 *
 * @Single
 * class MyService // Won't work without processor!
 * </noncompliant>
 *
 * <compliant>
 * // build.gradle.kts with:
 * plugins {
 *     id("com.google.devtools.ksp") version "..."
 * }
 * dependencies {
 *     ksp("io.insert-koin:koin-ksp-compiler:...")
 * }
 *
 * @Single
 * class MyService
 * </compliant>
 */
public class AnnotationProcessorNotConfigured(config: Config = Config.empty) : Rule(config) {
    override val issue: Issue = Issue(
        id = "AnnotationProcessorNotConfigured",
        severity = Severity.Warning,
        description = "Koin annotations used but processor may not be configured",
        debt = Debt.TEN_MINS
    )

    private val skipCheck = valueOrDefault("skipCheck", false)

    override fun visitClass(klass: KtClass) {
        super.visitClass(klass)

        if (skipCheck) return

        val annotations = klass.annotationEntries.mapNotNull { it.shortName?.asString() }
        if (annotations.any { it in setOf("Single", "Factory", "Scoped", "Module") }) {
            report(
                CodeSmell(
                    issue,
                    Entity.from(klass),
                    "Class uses Koin annotations (@Single, @Factory, etc.). " +
                            "Ensure KSP or KAPT is configured with koin-ksp-compiler. " +
                            "Otherwise, these definitions won't be generated. " +
                            "Configure skipCheck=true to disable this warning if processor is set up."
                )
            )
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `./gradlew test --tests "AnnotationProcessorNotConfiguredTest" --no-daemon`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/annotations/AnnotationProcessorNotConfigured.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/annotations/AnnotationProcessorNotConfiguredTest.kt
git commit -m "feat(annotations): add AnnotationProcessorNotConfigured rule

Warns when using Koin annotations without processor check.
Configurable via skipCheck parameter.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 2: DX Foundations - Suppression Support (Week 2, Days 1-2)

### Task 6: Add Suppression Support Infrastructure

**Note:** Detekt handles `@Suppress` automatically at the framework level. We need to verify it works and document it, but no code changes needed.

**Step 1: Test suppression on existing rule**

Create: `src/test/kotlin/io/github/krozov/detekt/koin/SuppressionTest.kt`

```kotlin
package io.github.krozov.detekt.koin

import io.github.krozov.detekt.koin.servicelocator.NoKoinComponentInterface
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.test.lint
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

class SuppressionTest {

    @Test
    fun `Suppress on class suppresses rule`() {
        val code = """
            import org.koin.core.component.KoinComponent

            @Suppress("NoKoinComponentInterface")
            class MyClass : KoinComponent
        """.trimIndent()

        val findings = NoKoinComponentInterface(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `Suppress on file suppresses all violations`() {
        val code = """
            @file:Suppress("NoKoinComponentInterface")

            import org.koin.core.component.KoinComponent

            class MyClass : KoinComponent
            class Another : KoinComponent
        """.trimIndent()

        val findings = NoKoinComponentInterface(Config.empty).lint(code)
        assertThat(findings).isEmpty()
    }

    @Test
    fun `Without Suppress violations are reported`() {
        val code = """
            import org.koin.core.component.KoinComponent

            class MyClass : KoinComponent
        """.trimIndent()

        val findings = NoKoinComponentInterface(Config.empty).lint(code)
        assertThat(findings).hasSize(1)
    }
}
```

**Step 2: Run test**

Run: `./gradlew test --tests "SuppressionTest" --no-daemon`
Expected: PASS (Detekt framework handles suppression)

**Step 3: Commit**

```bash
git add src/test/kotlin/io/github/krozov/detekt/koin/SuppressionTest.kt
git commit -m "test: verify @Suppress support works for all rules

Detekt framework provides @Suppress support automatically.
Tests verify it works correctly.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 3: DX Foundations - Enhanced Messages (Week 2, Days 3-5)

### Task 7: Define Enhanced Message Format

**Step 1: Create message format template**

All rules should follow this format:
```
[Problem] → [Why it's bad] → [How to fix] + [Code example]
```

Example:
```
KoinComponent interface found → Breaks dependency inversion, harder to test
→ Use constructor injection instead

✗ Bad:  class MyRepo : KoinComponent { val api = get<Api>() }
✓ Good: class MyRepo(private val api: Api)
```

**Step 2: Update one rule as example**

Modify: `src/main/kotlin/io/github/krozov/detekt/koin/servicelocator/NoKoinComponentInterface.kt`

Change report message from:
```kotlin
report(CodeSmell(..., "Class implements KoinComponent..."))
```

To:
```kotlin
report(
    CodeSmell(
        issue,
        Entity.from(klass),
        """
        KoinComponent interface found → Breaks dependency inversion, harder to test
        → Use constructor injection instead

        ✗ Bad:  class MyRepo : KoinComponent { val api = get<Api>() }
        ✓ Good: class MyRepo(private val api: Api)
        """.trimIndent()
    )
)
```

**Step 3: Update test to verify new message format**

Modify test in `NoKoinComponentInterfaceTest.kt`:

```kotlin
@Test
fun `reports with enhanced message format`() {
    val code = """
        import org.koin.core.component.KoinComponent

        class MyClass : KoinComponent
    """.trimIndent()

    val findings = NoKoinComponentInterface(Config.empty).lint(code)

    assertThat(findings).hasSize(1)
    assertThat(findings[0].message).contains("→")
    assertThat(findings[0].message).contains("✗ Bad")
    assertThat(findings[0].message).contains("✓ Good")
}
```

**Step 4: Run test**

Run: `./gradlew test --tests "NoKoinComponentInterfaceTest" --no-daemon`
Expected: PASS

**Step 5: Commit example**

```bash
git add src/main/kotlin/io/github/krozov/detekt/koin/servicelocator/NoKoinComponentInterface.kt \
        src/test/kotlin/io/github/krozov/detekt/koin/servicelocator/NoKoinComponentInterfaceTest.kt
git commit -m "feat(dx): add enhanced message format to NoKoinComponentInterface

Implement new message format: [Problem] → [Why] → [How] + [Example]
Serves as template for other rules.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

### Task 8: Batch Update All Rules with Enhanced Messages

**Note:** This is a large task - updating 24+ rules. Can be done in batches.

**Files to modify:** All rule implementation files

**For each rule:**
1. Update message to follow enhanced format
2. Add code example in message
3. Update tests to verify new format

**Example batch (5 rules at a time):**

Batch 1: Service Locator Rules
- NoGetOutsideModuleDefinition
- NoInjectDelegate
- NoGlobalContextAccess
- NoKoinGetInApplication
- NoKoinComponentInterface (already done)

Batch 2: Module DSL Rules
- EmptyModule
- SingleForNonSharedDependency
- MissingScopedDependencyQualifier
- DeprecatedKoinApi
- ModuleIncludesOrganization

Etc.

**Commit after each batch:**
```bash
git commit -m "feat(dx): enhance messages for [batch name] rules"
```

---

## Phase 4: Integration & Testing (Week 3, Days 1-2)

### Task 9: Update KoinRuleSetProvider with 5 New Rules

**Files:**
- Modify: `src/main/kotlin/io/github/krozov/detekt/koin/KoinRuleSetProvider.kt`
- Modify: `src/test/kotlin/io/github/krozov/detekt/koin/integration/KoinRulesIntegrationTest.kt`

**Step 1: Add imports for annotation rules**

```kotlin
// Annotation rules
import io.github.krozov.detekt.koin.annotations.MixingDslAndAnnotations
import io.github.krozov.detekt.koin.annotations.MissingModuleAnnotation
import io.github.krozov.detekt.koin.annotations.ConflictingBindings
import io.github.krozov.detekt.koin.annotations.ScopedWithoutQualifier
import io.github.krozov.detekt.koin.annotations.AnnotationProcessorNotConfigured
```

**Step 2: Register in RuleSet (24 → 29 rules)**

Add to `instance()` method:
```kotlin
// Annotation rules
MixingDslAndAnnotations(config),
MissingModuleAnnotation(config),
ConflictingBindings(config),
ScopedWithoutQualifier(config),
AnnotationProcessorNotConfigured(config)
```

**Step 3: Update integration test**

Change:
```kotlin
assertThat(ruleSet.rules).hasSize(29) // Was 24
```

Add rule IDs:
```kotlin
"MixingDslAndAnnotations",
"MissingModuleAnnotation",
"ConflictingBindings",
"ScopedWithoutQualifier",
"AnnotationProcessorNotConfigured"
```

**Step 4: Run tests**

Run: `./gradlew test --no-daemon`
Expected: PASS (all tests)

**Step 5: Commit**

```bash
git commit -m "feat: register 5 Koin Annotations rules in provider

Total rules: 24 → 29
- MixingDslAndAnnotations
- MissingModuleAnnotation
- ConflictingBindings
- ScopedWithoutQualifier
- AnnotationProcessorNotConfigured

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 5: Documentation (Week 3, Days 3-4)

### Task 10: Update Documentation

**Files:**
- Modify: `docs/rules.md`
- Modify: `README.md`

**Step 1: Add Annotations section to docs/rules.md**

Add new section:
```markdown
## Koin Annotations Rules

### MixingDslAndAnnotations

**Severity:** Warning
**Active:** Yes

Detects mixing DSL and Annotations in same file...
[Full documentation with examples]

### MissingModuleAnnotation
...
[etc for all 5 rules]
```

**Step 2: Update README.md**

Change:
- "24 rules" → "29 rules"
- Add Koin Annotations section to table

**Step 3: Commit**

```bash
git commit -m "docs: add documentation for 5 Koin Annotations rules

Update README: 24 → 29 rules
Add complete Annotations section to docs/rules.md

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Phase 6: Final Verification & Release (Week 3, Day 5)

### Task 11: Coverage & Build Verification

**Step 1: Run full test suite**

Run: `./gradlew clean test --no-daemon`
Expected: PASS

**Step 2: Verify coverage**

Run: `./gradlew koverHtmlReport koverVerify`
Expected: ≥98% line, ≥70% branch

**Step 3: Full build**

Run: `./gradlew build --no-daemon`
Expected: BUILD SUCCESSFUL

---

### Task 12: Version Bump & Release

**Step 1: Update version**

Modify `build.gradle.kts`:
```kotlin
version = "0.3.0"
```

Update description:
```kotlin
description.set(
    "Detekt extension library with 29 rules for Koin 4.x..."
)
```

**Step 2: Commit**

```bash
git commit -m "chore: bump version to 0.3.0

Release highlights:
- 5 Koin Annotations rules
- @Suppress support verified
- Enhanced messages for all 29 rules
- Comprehensive DX improvements

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**Step 3: Create tag**

```bash
git tag -a v0.3.0 -m "Release v0.3.0: Koin Annotations + DX Foundations

New Rules (5):
- MixingDslAndAnnotations
- MissingModuleAnnotation
- ConflictingBindings
- ScopedWithoutQualifier
- AnnotationProcessorNotConfigured

DX Improvements:
- @Suppress support verified
- Enhanced error messages with examples
- Better configuration options

Total: 29 rules, 250+ tests, 98%+ coverage"
```

**Step 4: Push**

```bash
git push origin main --tags
```

---

## Success Criteria

✅ **5 new annotation rules implemented**
✅ **Suppression support verified** (@Suppress works)
✅ **Enhanced messages** for all 29 rules
✅ **Test coverage:** ≥98% line / ≥70% branch
✅ **Documentation:** Complete for all rules
✅ **CI/CD:** All checks passing
✅ **Version:** 0.3.0 tagged and released

---

## Timeline Summary

- **Week 1 (Days 1-5):** Annotation rules (Tasks 1-5)
- **Week 2 (Days 1-2):** Suppression support (Task 6)
- **Week 2 (Days 3-5):** Enhanced messages (Tasks 7-8)
- **Week 3 (Days 1-2):** Integration (Task 9)
- **Week 3 (Days 3-4):** Documentation (Task 10)
- **Week 3 (Day 5):** Verification & release (Tasks 11-12)

**Total: ~15 working days (3 weeks)**

---

## Next Version

After v0.3.0 release, proceed to v0.4.0:
- 10+ auto-fixes for common violations
- Baseline file support
- Advanced configuration features
